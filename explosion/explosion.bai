' this function decomposes the object from
' a connected set of linesprites, to a set of moveto/drawto
' so that we are moving around indvidual lines.
'
' it will also precalculate the centrepoint atan2 angles, since we will absolutely 
' need this for performance....
'
' Params:
' dimensions - 2 or 3
' obj - the LinesSprite format object
' world_scale - scale of the world
' point - where to explode
' x_impulse - base impulse to hit object with on the x axis
' y_impulse - base impulse to hit object with on the y axis
' x_random - additional random impulse for x
' y_random - additional random impulse for y
' break_apart - true/false - do we break the vectors?
function prepare_explosion(dimensions, obj, world_scale, point, impulse, random, gravity, ground, break_apart)
  Struct ExpStruct {dest, accel, gravity, time, ground}
  if break_apart
    work_object = break_apart_object(obj, dimensions)
  else
    work_object = DeepCopy(obj)
  endif
  ' set up the acceleration table here for now
  dim work_accel[Ubound(work_object), dimensions]
  for vertex = 1 to Ubound(work_object)
    if dimensions = 2
      my_vector = {work_object[vertex, 2]-point[1], work_object[vertex, 3]-point[2]}
    else
      my_vector = {work_object[vertex, 2]-point[1], work_object[vertex, 3]-point[2],  work_object[vertex, 4]-point[3]}
    endif
    my_vector = my_vector / norm(my_vector)
    my_vector = my_vector * world_scale
    for x = 1 to dimensions
      rfactor = ((rand() mod 256)/256.0) * random[x]
      work_accel[vertex, x] = my_vector[x] * (impulse[x] + rfactor)
    next
  next
  exp_obj = ExpStruct(work_object, work_accel, gravity*world_scale, 0.0, ground)
  return exp_obj
endfunction

function break_apart_object(obj, d)
  final_vcount = 0
  for j = 1 to Ubound(obj)
    if obj[j, 1] = DrawTo
      final_vcount = final_vcount + 2
    endif
  next
  dim workobj[final_vcount, d+1]
  v = 1
  last_v = {0,0,0}
  for j = 1 to Ubound(obj)
    if obj[j, 1] = DrawTo
      workobj[v, 1] = MoveTo
      workobj[v+1, 1] = DrawTo
      for x = 1 to d
        workobj[v, x+1] = lastv[x]
        workobj[v+1, x+1] = obj[j, x+1]
      next
      v = v + 2
    endif
    if d = 2
      lastv = { obj[j, 2], obj[j, 3] }
    else
      lastv = { obj[j, 2], obj[j, 3], obj[j, 4] }
    endif
  next
  return workobj
endfunction

' this function does the actual exploding
sub explode2d(workobj)
  ' update the time
  now = GetTickCount()
  if workobj.time = 0
    workobj.time = now
    return
  endif
  real_time = (now - workobj.time) / 960.0
  workobj.time = now

  ' optimization so we're not looking these up constantly
  dest = workobj.dest
  accel = workobj.accel
  ground = workobj.ground
  gravity = workobj.gravity

  ' accelerate the verticies
  for vertex = 1 to Ubound(dest)
    ' shift according to acccel*time
    dest[vertex, 2] = dest[vertex, 2] + accel[vertex, 1] * real_time
    dest[vertex, 3] = dest[vertex, 3] + accel[vertex, 2] * real_time

    ' apply gravity 
    accel[vertex, 2] = accel[vertex, 2] - (gravity * real_time)

    ' we hit the ground - great!
    if dest[vertex, 3] < ground
      dest[vertex,3] = ground
      accel[vertex, 1] = 0
      accel[vertex, 2] = 0
    endif
  next
endsub

sub explode3d(workobj)
  ' update the time
  now = GetTickCount()
  if workobj.time = 0
    workobj.time = now
    return
  endif
  real_time = (now - workobj.time) / 960.0
  workobj.time = now

  ' accelerate the verticies
  for vertex = 1 to Ubound(workobj.dest)
    ' shift according to acccel*time
    workobj.dest[vertex, 2] = workobj.dest[vertex, 2] + workobj.accel[vertex, 1] * real_time
    workobj.dest[vertex, 3] = workobj.dest[vertex, 3] + workobj.accel[vertex, 2] * real_time
    workobj.dest[vertex, 4] = workobj.dest[vertex, 4] + workobj.accel[vertex, 3] * real_time
    
  ' apply gravity 
    workobj.accel[vertex, 2] = workobj.accel[vertex, 2] - (workobj.gravity * real_time)
  
  ' we hit the ground - great!
    if workobj.dest[vertex, 3] < workobj.ground
      workobj.dest[vertex,3] = workobj.ground
      workobj.accel[vertex, 1] = 0
      workobj.accel[vertex, 2] = 0
      workobj.accel[vertex, 3] = 0
    endif

  next
endsub

